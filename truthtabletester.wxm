/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 23.05.1 ] */
/* [wxMaxima: input   start ] */
/* #---=== Data ===---# */;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M:matrix([1,0,1,0,1],[0,1,1,0,1],[0,0,0,0,0],[1,1,1,1,0]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
N:matrix([0,1,1,0,1],[1,0,1,0,1],[0,0,0,0,0],[1,1,1,1,0]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Nwrong:matrix([0,1,1,0,1],[1,0,0,0,0],[0,0,1,0,1],[1,1,1,1,0]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M2:matrix([1,1,1,1,0],[1,0,1,0,1],[0,1,1,0,1],[0,0,0,0,0]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
signals3: transpose(matrix([0,1,0,0,1,0,1,1],[0,0,1,0,1,1,0,1],[0,0,0,1,0,1,1,1]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responses3: transpose(matrix([0,0,0,0,1,0,0,1],[0,1,1,1,1,1,1,1],[1,1,1,0,1,0,0,0]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
signals1: matrix([0],[1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responses1: transpose(matrix([1,0],[0,1]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M1A: addcol(signals1, responses1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M1B: colswap(M1A,2,3);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
transpose(M1A);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rowswap(transpose(M1A),1,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
M3: addcol(signals3,responses3);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
is(equal(M,M2));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Mresponse: submatrix(M,1,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responseCols: makelist(i,i,3,5);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Msignal: apply(submatrix, cons(M, responseCols));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
addcol(Msignal, Mresponse);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* #---=== Funktions ===---# */
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
matsize(A):=[length(A),length(transpose(A))];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rowsums(A):=map(lambda([r], [lsum(x, x, r)]), A);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
colsums(A):=transpose(map(lambda([r], [lsum(x, x, r)]), transpose(A)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortedRowsums(A):= sort(flatten(args(rowsums(A))));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortedColsums(A):= sort(flatten(args(colsums(A))));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRow(A,colIdx) :=  apply('matrix,sort(args(A), lambda([a,b], a[colIdx]<b[colIdx])));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortBy2Rows(A,colIdx1,colIdx2) :=  apply('matrix,sort(args(A), lambda([a,b], 
            /*
            print(a, b),
            print(a[colIdx1],"<",b[colIdx1],":",result),
            */
            result: a[colIdx1]<b[colIdx1],
            if a[colIdx1]=b[colIdx1] then result: a[colIdx2]<b[colIdx2]
        )));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
/*
sortByRows(A,[colIdxs]) :=  block(
    print(A),
    end: length(colIdxs),
    result: false,
    apply('matrix,sort(args(A), lambda([a,b],
            print(a, b),
            for i:1 thru end do (
                print("i: ",i),
                result: a[colIdxs[i]]<b[colIdxs[i]],
                print(a[colIdxs[i]],"<",b[colIdxs[i]],":",is(result)),
                if not a[colIdxs[i]]=b[colIdxs[i]] or i = end then return(result)
            )
        ))),
    return(A)
);
*/
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByCol(A,rowIdx) :=  transpose(apply('matrix,sort(args(transpose(A)), lambda([a,b], a[rowIdx]<b[rowIdx]))));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWithIndex(A, index) := submatrix(sortByRow(addcol(index,A),1),1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWith2Indices(A, [indices]) := submatrix(sortBy2Rows(addcol(indices[1],indices[2],A),1,2),1,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByColsum(A) := submatrix(1,sortByCol(addrow(colsums(A),A),1));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
getRowIndex(A,colIdx,value):= block(
    index: -1,    
    for i:1 thru length(A) do block(
        if A[i][colIdx] = value then index: i
    ),
    return(index)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
getColsumGroups(A):= block(
    csums: flatten(args(colsums(A))),
    csumGroups: makelist(set(),length(A)+1),
    for i:1 thru length(csums) do (
        csumGroups[csums[i]+1]: adjoin(i, csumGroups[csums[i]+1])
    ),
    return(csumGroups)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
getColsumGroups(M1A);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
colswap(A,i,j):= transpose(rowswap(transpose(A),i,j));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
reorderMatrixCols(A, p):= block(
    apply(addcol, map(lambda([p], col(A,p)), p))
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
reorderMatrixRows(A, p):= block(
    apply(addrow, map(lambda([p], row(A,p)), p))
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
permutationsForGrouping(groups):= block(
    first: true,
    result: [],
    for i1 in groups do (
        p: listify(permutations(i1)),
        if first then (
            result: p,
            /* print(result), */
            first: false
        ) else (
            temp: makelist([], length(result)*length(p)),
            for i3:1 thru length(result) do (
            /* print(p, length(p)), */
                for i2:1 thru length(p) do (
                        temp[(i2-1)*length(result)+i3]: append(result[i3], p[i2])
                )
            ),
            /* print(temp), */
            result: temp
        )
    ),
    return(result)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(A,B,n_inputs,[debuginfo]) := block(
    if length(debuginfo) = 0 then debuginfo: ["null"],
    
    isEqual: false,
    if Ar = Br and As = Bs then (
        print("They are identical."),
        isEqual: true,
        return(true)
    ),
    
    dimA: matsize(A),
    count: 0,
    /* check for equal dimensions */
    if dimA = matsize(B) then (
        n_outputs: dimA[2]-n_inputs,
        signalCols: makelist(i,i,1,n_inputs),
        responseCols: makelist(i,i,n_inputs+1,dimA[2]),
        Ar: apply(submatrix, cons(A, signalCols)),
        Br: apply(submatrix, cons(B, signalCols)),
        print(Ar, Br),
        print(sortedColsums(Ar),sortedColsums(Br)),
        
        /* check for equal colsums and rowsums for responses */
        if sortedRowsums(Ar) = sortedRowsums(Br) then (
            if sortedColsums(Ar) = sortedColsums(Br) then (
                /* check for equal rowsums */
                if sortedRowsums(A) = sortedRowsums(B) then (
                    /* catch and throw is the only way to escape multiple loops; return only jumps back one block / do */
                    catch (                        
                        permutationsColsSignalsB: permutations(signalCols),
                
                        /* 
                        Idea:
                        sort by tuple groups of rowsums and response rowsums
                        only check permutations where rows have same rowsums
                        */
                        /* sort for response row sums first (will decide draws in main sorting) */
                        responseRowsumIndexA: rowsums(apply(submatrix, cons(A, signalCols))),
                        responseRowsumIndexB: rowsums(apply(submatrix, cons(B, signalCols))),
                        A: sortByRowWithIndex(A, responseRowsumIndexA),
                        B: sortByRowWithIndex(B, responseRowsumIndexB),
                        /* sort for total rowsums */
                        rowsumIndexA: rowsums(A),
                        rowsumIndexB: rowsums(B),
                        A: sortByRowWithIndex(A, rowsumIndexA),
                        B: sortByRowWithIndex(B, rowsumIndexB),
                        rowsumIndexA: flatten(args(rowsums(A))),
                        rowsumIndexB: flatten(args(rowsums(B))),
                
                        Aresponses: sortByColsum(apply(submatrix, cons(A, signalCols))),
                        Bresponses: sortByColsum(apply(submatrix, cons(B, signalCols))),
                        responseRowsumIndexA: flatten(args(rowsums(Aresponses))),
                        responseRowsumIndexB: flatten(args(rowsums(Bresponses))),
                        
                        groups: makelist([], (lmax(rowsumIndexA)+1)*(lmax(responseRowsumIndexA)+1)),
                        for i:1 thru length(rowsumIndexA) do (
                            groups[rowsumIndexA[i]+1+(responseRowsumIndexA[i])*(lmax(responseRowsumIndexA)+1)]: append(groups[rowsumIndexA[i]+1+(responseRowsumIndexA[i])*(lmax(responseRowsumIndexA)+1)], [i])
                        ),
                        permutationsRowsB: permutationsForGrouping(groups),
    
                        /* 
                        Idea:
                        sort responses by colsums
                        only check permutations where cols have same colsums 
                        */
                        Asignals: apply(submatrix, cons(A, responseCols)),
                        A: addcol(Asignals, Aresponses),
                        Bsignals: apply(submatrix, cons(B, responseCols)),
                        B: addcol(Bsignals, Bresponses),
                
                        colsumIndex: flatten(args(colsums(Aresponses))),
                        groupsResponseCols: makelist([],lmax(colsumIndex)+1),
                        for i:1 thru length(colsumIndex) do (
                            groupsResponseCols[colsumIndex[i]+1]: append(groupsResponseCols[colsumIndex[i]+1], [i]+n_inputs)
                        ),
                        
                        permutationsColsResponsesB: permutationsForGrouping(groupsResponseCols),
                
                        /* loop over all permutation combinations */
                        for i1 in permutationsRowsB do (           
                            for i2 in permutationsColsSignalsB do (
                                for i3 in permutationsColsResponsesB do (
                                    count: count+1,
                                    colOrder: append(i2,i3),
                                    tempB: reorderMatrixCols(reorderMatrixRows(B, i1), colOrder),
                                    
                                    if A = tempB then (
                                        if member("true", debuginfo) then (
                                            print("They are equivalent at iteration", count,":"),
                                            print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "==", tempB)
                                        ),                            
                                        isEqual: true,
                                        if not member("full", debuginfo) then throw(true)
                                        /* comment the throw to get max iterations */
                                    ) else if member("verbose", debuginfo) then print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "!=", tempB)
                                )
                            )
                        )
                    )
                ) else (print("The matrices rowsums are unequal but response submatrices rowsums are equal."))
            ) else (print("The response submatrices colsums are unequal."))
        ) else (print("The response submatrices rowsums are unequal."))
    ) else (print("The matrices dimensions are unequal.")),
    
    if member("true", debuginfo) then print("It needed", count, "iterations."),
    return(isEqual)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
truthtable_isequal_ColsumsAndRowResponseTupleSums_groups(A,B,n_inputs,[debuginfo]) := block(
    if length(debuginfo) = 0 then debuginfo: ["null"],
    /* print(debuginfo), */
    
    isEqual: false,
    if Ar = Br and As = Bs then (
        print("They are identical."),
        isEqual: true,
        return(true)
    ),
    
    dimA: matsize(A),
    count: 0,
    /* check for equal dimensions */
    if dimA = matsize(B) then (
        /* catch and throw is the only way to escape multiple loops; return only jumps back one block / do */
        catch (
            n_outputs: dimA[2]-n_inputs,
            signalCols: makelist(i,i,1,n_inputs),
            responseCols: makelist(i,i,n_inputs+1,dimA[2]),
            
            permutationsColsSignalsB: permutations(signalCols),
    
            /* 
            Idea:
            sort by tuple groups of rowsums and response rowsums
            only check permutations where rows have same rowsums
            */
            /* sort for response row sums first (will decide draws in main sorting) */
            responseRowsumIndexA: rowsums(apply(submatrix, cons(A, signalCols))),
            responseRowsumIndexB: rowsums(apply(submatrix, cons(B, signalCols))),
            A: sortByRowWithIndex(A, responseRowsumIndexA),
            B: sortByRowWithIndex(B, responseRowsumIndexB),
            /* sort for total rowsums */
            rowsumIndexA: rowsums(A),
            rowsumIndexB: rowsums(B),
            A: sortByRowWithIndex(A, rowsumIndexA),
            B: sortByRowWithIndex(B, rowsumIndexB),
            rowsumIndexA: flatten(args(rowsums(A))),
            rowsumIndexB: flatten(args(rowsums(B))),
    
            Aresponses: sortByColsum(apply(submatrix, cons(A, signalCols))),
            Bresponses: sortByColsum(apply(submatrix, cons(B, signalCols))),
            responseRowsumIndexA: flatten(args(rowsums(Aresponses))),
            responseRowsumIndexB: flatten(args(rowsums(Bresponses))),
                
            groups: makelist([], (lmax(rowsumIndexA)+1)*(lmax(responseRowsumIndexA)+1)),
            for i:1 thru length(rowsumIndexA) do (
                            groups[rowsumIndexA[i]+1+(responseRowsumIndexA[i])*(lmax(responseRowsumIndexA)+1)]: append(groups[rowsumIndexA[i]+1+(responseRowsumIndexA[i])*(lmax(responseRowsumIndexA)+1)], [i])
            ),
            permutationsRowsB: permutationsForGrouping(groups),
    
            /* 
            Idea:
            sort responses by colsums
            only check permutations where cols have same colsums 
            */
            Asignals: apply(submatrix, cons(A, responseCols)),
            A: addcol(Asignals, Aresponses),
            Bsignals: apply(submatrix, cons(B, responseCols)),
            B: addcol(Bsignals, Bresponses),
    
            colsumIndex: flatten(args(colsums(Aresponses))),
            groupsResponseCols: makelist([],lmax(colsumIndex)+1),
            for i:1 thru length(colsumIndex) do (
                groupsResponseCols[colsumIndex[i]+1]: append(groupsResponseCols[colsumIndex[i]+1], [i]+n_inputs)
            ),
            
            permutationsColsResponsesB: permutationsForGrouping(groupsResponseCols),
    
            /* loop over all permutation combinations */
            for i1 in permutationsRowsB do (           
                for i2 in permutationsColsSignalsB do (
                    for i3 in permutationsColsResponsesB do (
                        count: count+1,
                        colOrder: append(i2,i3),
                        tempB: reorderMatrixCols(reorderMatrixRows(B, i1), colOrder),
                        
                        if A = tempB then (
                            if member("true", debuginfo) then (
                                print("They are equivalent at iteration", count,":"),
                                print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "==", tempB)
                            ),                            
                            isEqual: true,
                            if not member("full", debuginfo) then throw(true)
                            /* comment the throw to get max iterations */
                        ) else if member("verbose", debuginfo) then print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "!=", tempB)
                    )
                )
            )
        )
    ) else (print("The matrices dimensions are unequal.")),
    
    if member("true", debuginfo) then print("It needed", count, "iterations."),
    return(isEqual)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
truthtable_isequal_colAndRowsum_groups(A,B,n_inputs,[debuginfo]) := block(
    if length(debuginfo) = 0 then debuginfo: ["null"],
    /* print(debuginfo), */
    
    isEqual: false,
    if Ar = Br and As = Bs then (
        print("They are identical."),
        isEqual: true,
        return(true)
    ),
    
    dimA: matsize(A),
    count: 0,
    /* check for equal dimensions */
    if dimA = matsize(B) then (
        /* catch and throw is the only way to escape multiple loops; return only jumps back one block / do */
        catch (
            n_outputs: dimA[2]-n_inputs,
            signalCols: makelist(i,i,1,n_inputs),
            responseCols: makelist(i,i,n_inputs+1,dimA[2]),
            
            permutationsColsSignalsB: permutations(signalCols),
    
            /* 
            Idea:
            sort by rowsums (or even better by tuple groups of rowsums for signals and results)
            only check permutations where rows have same rowsums
            */
            rowsumIndexA: rowsums(A),
            rowsumIndexB: rowsums(B),
            A: sortByRowWithIndex(A, rowsumIndexA),
            B: sortByRowWithIndex(B, rowsumIndexB),
            rowsumIndexA: flatten(args(rowsums(A))),
            rowsumIndexB: flatten(args(rowsums(B))),
    
            groups: makelist([],lmax(rowsumIndexA)+1),
            for i:1 thru length(rowsumIndexA) do (
                groups[rowsumIndexA[i]+1]: append(groups[rowsumIndexA[i]+1], [i])
            ),
            permutationsRowsB: permutationsForGrouping(groups),
            
            /* 
            Idea:
            sort responses by colsums
            only check permutations where cols have same colsums 
            */
            Asignals: apply(submatrix, cons(A, responseCols)),
            Aresponses: sortByColsum(apply(submatrix, cons(A, signalCols))),
            A: addcol(Asignals, Aresponses),
            Bsignals: apply(submatrix, cons(B, responseCols)),
            Bresponses: sortByColsum(apply(submatrix, cons(B, signalCols))),
            B: addcol(Bsignals, Bresponses),
    
            colsumIndex: flatten(args(colsums(Aresponses))),
            groupsResponseCols: makelist([],lmax(colsumIndex)+1),
            for i:1 thru length(colsumIndex) do (
                groupsResponseCols[colsumIndex[i]+1]: append(groupsResponseCols[colsumIndex[i]+1], [i]+n_inputs)
            ),
            permutationsColsResponsesB: permutationsForGrouping(groupsResponseCols),
    
            /* loop over all permutation combinations */
            for i1 in permutationsRowsB do (           
                for i2 in permutationsColsSignalsB do (
                    for i3 in permutationsColsResponsesB do (
                        count: count+1,
                        colOrder: append(i2,i3),
                        tempB: reorderMatrixCols(reorderMatrixRows(B, i1), colOrder),
                        
                        if A = tempB then (
                            if member("true", debuginfo) then (
                                print("They are equivalent at iteration", count,":"),
                                print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "==", tempB)
                            ),                            
                            isEqual: true,
                            if not member("full", debuginfo) then throw(true)
                            /* comment the throw to get max iterations */
                        ) else if member("verbose", debuginfo) then print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "!=", tempB)
                    )
                )
            )
        )
    ) else (print("The matrices dimensions are unequal.")),
    
    if member("true", debuginfo) then print("It needed", count, "iterations."),
    return(isEqual)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
truthtable_isequal_rowsum_groups(A,B,n_inputs,[debuginfo]) := block(
    if length(debuginfo) = 0 then debuginfo: ["null"],
    /* print(debuginfo), */
    
    isEqual: false,
    if Ar = Br and As = Bs then (
        print("They are identical."),
        isEqual: true,
        return(true)
    ),
    
    dimA: matsize(A),
    count: 0,
    /* check for equal dimensions */
    if dimA = matsize(B) then (
        /* catch and throw is the only way to escape multiple loops; return only jumps back one block / do */
        catch (
            n_outputs: dimA[2]-n_inputs,
            signalCols: makelist(i,i,1,n_inputs),
            responseCols: makelist(i,i,n_inputs+1,dimA[2]),
            
            permutationsColsSignalsB: permutations(signalCols),
            permutationsColsResponsesB: permutations(responseCols),
    
            /* 
            Idea:
            sort by rowsums (or even better by tuple groups of rowsums for signals and results)
            only check permutations where rows have same rowsums
            */
            rowsumIndexA: rowsums(A),
            rowsumIndexB: rowsums(B),
            A: sortByRowWithIndex(A, rowsumIndexA),
            B: sortByRowWithIndex(B, rowsumIndexB),
            rowsumIndexA: flatten(args(rowsums(A))),
            rowsumIndexB: flatten(args(rowsums(B))),
    
            /* print(rowsumIndexA), */
            groups: makelist([],lmax(rowsumIndexA)+1),
            for i:1 thru length(rowsumIndexA) do (
                groups[rowsumIndexA[i]+1]: append(groups[rowsumIndexA[i]+1], [i])
            ),
            /*            
            print(groups),
            print(permutationsForGrouping(groups)),
            */
            permutationsRowsB: permutationsForGrouping(groups),
    
            /* loop over all permutation combinations */
            for i1 in permutationsRowsB do (           
                for i2 in permutationsColsSignalsB do (
                    for i3 in permutationsColsResponsesB do (
                        count: count+1,
                        colOrder: append(i2,i3),
                        tempB: reorderMatrixCols(reorderMatrixRows(B, i1), colOrder),
                        
                        if A = tempB then (
                            if member("true", debuginfo) then (
                                print("They are equivalent at iteration", count,":"),
                                print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "==", tempB)
                            ),                            
                            isEqual: true,
                            if not member("full", debuginfo) then throw(true)
                            /* comment the throw to get max iterations */
                        ) else if member("verbose", debuginfo) then print("i1:", i1, "| i2:", i2, "| i3:", i3, "=>", A, "!=", tempB)
                    )
                )
            )
        )
    ) else (print("The matrices dimensions are unequal.")),
    
    if member("true", debuginfo) then print("It needed", count, "iterations."),
    return(isEqual)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
n_inpu
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
/* not correct working */
truthtable_isequal_firstAttempt(A,B,n_inputs) := block(
    isEqual: false,
    if A = B then (
        isEqual: true,
        return(true)
    ),
    
    /* check for equal dimensions */
    /* exclude unconnected in- and outputs before! */
    dimA: matsize(A),
    if dimA = matsize(B) then (
        /* create submatrices */
        n_outputs: dimA[2]-n_inputs,
        signalCols: makelist(i,i,1,n_inputs),
        responseCols: makelist(i,i,n_inputs+1,dimA[2]),
        Ar: apply(submatrix, cons(A, signalCols)),
        Br: apply(submatrix, cons(B, signalCols)),
        As: apply(submatrix, cons(A, responseCols)),
        Bs: apply(submatrix, cons(B, responseCols)),
        
        /* check for equal colsums and rowsums for responses */
        if sortedRowsums(Ar) = sortedRowsums(Br) then (
            if sortedColsums(Ar) = sortedColsums(Br) then (
                /* check for equal rowsums */
                if sortedRowsums(A) = sortedRowsums(B) then (
                    /* create working matrix */
                    Ar: sortByColsum(Ar),
                    Br: sortByColsum(Br),
                    rsumsAr: rowsums(Ar),
                    rsumsBr: rowsums(Br),
                    rsumsAs: rowsums(As),
                    rsumsBs: rowsums(Bs),
                    rowindex: makelist(i,i,1,dimA[1]),
                    rowIdxNum: dimA[2]+3,
                    mask: makelist(i,i,dimA[2]+1,rowIdxNum),
                    
                    /* don't work with rowsums anymore because of rowindexColumn */
                    A: sortByRowWithIndex(addcol(As, Ar, rsumsAs, rsumsAr, rowindex), rsumsAr),
                    B: sortByRowWithIndex(addcol(Bs, Br, rsumsBs, rsumsBr, rowindex), rsumsBr),
                    print(A,B),
                    /*
                    if A = B then (
                        isEqual: true,
                        return: true
                    )
                    */
                    
                    rowGrouping: makelist(makelist(makelist(set(),2),n_outputs+1), n_inputs+1),
                    groupSizeMap: makelist(set(), dimA[1]),
                    
                    for i:1 thru dimA[1] do (
                        inIdxA: A[i][dimA[2]+1]+1,
                        outIdxA: A[i][dimA[2]+2]+1,
                        rowIdxA: A[i][rowIdxNum],
                        inIdxB: B[i][dimA[2]+1]+1,
                        outIdxB: B[i][dimA[2]+2]+1,
                        rowIdxB: B[i][rowIdxNum],
                        
                        rowGrouping[inIdxA][outIdxA][1]: adjoin(rowIdxA,rowGrouping[inIdxA][outIdxA][1]),
                        rowGrouping[inIdxB][outIdxB][2]: adjoin(rowIdxB,rowGrouping[inIdxB][outIdxB][2])
                    ),
                    print(rowGrouping),
                    
                    for i:1 thru length(rowGrouping) do (
                        for j:1 thru length(rowGrouping[1]) do (
                            s: rowGrouping[i][j][1],
                            sSize: cardinality(s),
                            if sSize > 0 then groupSizeMap[sSize]: adjoin([i,j], groupSizeMap[sSize])
                        )
                    ),
                    print(groupSizeMap),
                    
                    /*
                    A: sortByRow(A,rowIdxNum),
                    B: sortByRow(B,rowIdxNum),
                    */
                                       
                    for i in groupSizeMap do (
                        for e in i do (
                            /*
                            print(e),
                            print(listify(rowGrouping[e[1]][e[2]][1]), listify(rowGrouping[e[1]][e[2]][2])),
                            */
                            for j in listify(rowGrouping[e[1]][e[2]][1]) do (
                                for k in listify(rowGrouping[e[1]][e[2]][2]) do (
                                    rowIdxA: getRowIndex(A,rowIdxNum,j),
                                    rowIdxB: getRowIndex(B,rowIdxNum,k),
                                    if not rowIdxA = -1 and not rowIdxB = -1 then (
                                        rowA: apply(submatrix, cons(row(A, rowIdxA), mask)),
                                        rowB: apply(submatrix, cons(row(B, rowIdxB), mask)),
                                        /*
                                        print(j, rowIdxA, rowA, k, rowIdxB, rowB),
                                        print(A,B),
                                        */
                                        if rowA = rowB then (
                                            print("Die könnte man löschen."),
                                            A: submatrix(rowIdxA, A),
                                            B: submatrix(rowIdxB, B),
                                            
                                            if length(A) = 0 then (
                                                isEqual: true,
                                                return(true)
                                            )
                                        )
                                        else (
                                            print("Die könnte man nicht löschen.")
                                        )
                                    ) else print("Hier wurde wohl schon was gelöscht.")
                                )
                            )
                        )
                    ),
                    print(A,B)
                ) else (print("The matrices rowsums are unequal but response submatrices rowsums are equal."))
            ) else (print("The response submatrices colsums are unequal."))
        ) else (print("The response submatrices rowsums are unequal."))
    ) else (print("The matrices dimensions are unequal.")),
    
    return(isEqual)
);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* #---=== Tests ===---# */;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_bruteforce(M1A,M1B,1,"true","verbose","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_bruteforce(M,N,2,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_rowsum_groups(M,N,2,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_colAndRowsum_groups(M,N,2,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_ColsumsAndRowResponseTupleSums_groups(M,N,2,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M,N,2,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_bruteforce(M3,rowswap(M3, 4,6),3,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_rowsum_groups(M3,rowswap(M3, 4,6),3,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_colAndRowsum_groups(M3,rowswap(M3, 4,6),3,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_ColsumsAndRowResponseTupleSums_groups(M3,rowswap(M3, 4,6),3,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M3,rowswap(M3, 4,6),3,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_bruteforce(M,Nwrong,2,"true");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_rowsum_groups(M,Nwrong,2,"true");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_colAndRowsum_groups(M,Nwrong,2,"true");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M,Nwrong,2,"true");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Q1: matrix([0,1,0],[1,0,1]);
Q2: matrix([0,0,1],[1,1,0]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(Q1,Q2,1,"true","full");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal_bruteforce(Q1,Q2,1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* old tests */
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M1A,M1B,1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: hide output   ] *//* [wxMaxima: input   start ] */
truthtable_isequal(M,N,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M,Nwrong,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M3,M3,3);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
/* ad hoc try out */
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Nsort: addrow(transpose(colsums(N)),N);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
transpose(sortByCol(Nsort,1));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sort(args(transpose(Nsort)), lambda([a,b], a[1]<b[1]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByColsum(N);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWithIndex(N,rowsums(N));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWithIndex(submatrix(N,3,4,5),rowsums(N));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWithIndex(submatrix(N,1,2),rowsums(N));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
permutations(makelist(i,i,3));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list: makelist(makelist(makelist(set(),2),4), 3);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list[1][1][1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
l:makelist();
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list[1][1][1]: adjoin(1,list[1][1][1]);
adjoin(2,list[1][1][1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
set([1,2],[2,3]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
length(list);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
length(M);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
getRowIndex(Nwrong,1,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(M,M,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
N2: submatrix(1,2,3,N);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
submatrix(1,N2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */

/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
append([1,2], [[4,3], [3,4]], [5,6]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
permutations([1,2,[3,4]]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
outermap("+", [3,4], [1,2]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
permutations([3,4]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
groups: [[1,2],[3],[4,5]];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
result: [];
for i in groups do (
    result: outermap("[", i, result)
);
print(result);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
result: [1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
p: permutations([2,3,4]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
temp: makelist([], length(result)*length(p));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for i:1 thru length(p) do (
    temp[i]: append(result, listify(p)[i])
);
print(temp);
result: temp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
p: permutations([5,6]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
temp2: makelist([], length(result)*length(p));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for i:1 thru length(p) do (
    for j:1 thru length(result) do (
            temp2[(i-1)*length(result)+j]: append(result[j], listify(p)[i])
    )
);
print(temp2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
length(temp2) ;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
permutationsForGrouping(groups);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rowsumIndexA: transpose(matrix(flatten(sortedRowsums(N))));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lmax(flatten(args(rowsumIndexA)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
length(rowsumIndexA);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
matrix(sortedColsums(N));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
is(equal(0,1));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortBy2Rows(matrix([0,0,1],[1,0,2],[0,1,2]),3,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortBy2Rows(matrix([0,0,1],[0,1,2],[1,0,2]),3,2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
[1,2,3]+3;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Mx: matrix([0,0,0],[0,0,1],[0,1,0],[0,1,1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rowsumIndexMx: rowsums(Mx);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Mxresponses: apply(submatrix, cons(Mx, [1,2]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responseRowsumIndexMx: rowsums(Mxresponses);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWithIndex(Mx, rowsumIndexMx);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortByRowWith2Indices(Mx,rowsumIndexMx,responseRowsumIndexMx );
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
signals3: transpose(matrix([0,1,0,0,1,0,1,1],[0,0,1,0,1,1,0,1],[0,0,0,1,0,1,1,1]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responses3A: transpose(matrix([0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,0,0,1,0,0,0,0]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Q3A: addcol(signals3, responses3A);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
responses3B: transpose(matrix([0,1,0,0,0,0,0,0],[0,1,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Q3B: addcol(signals3, responses3B);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
truthtable_isequal(Q3A, Q3B, 3, "full", "true");
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
colsums(responses3B);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
colsums(responses3A);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sortedColsums(responses3B);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
flatten(sort(args(colsums(responses3B))));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sort(flatten(args(colsums(responses3B))));
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 23.05.1"$
